"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3303],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>c});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),d=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=d(a),c=n,h=u["".concat(s,".").concat(c)]||u[c]||p[c]||o;return a?r.createElement(h,i(i({ref:t},m),{},{components:a})):r.createElement(h,i({ref:t},m))}));function c(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var d=2;d<o;d++)i[d]=a[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},83249:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>d,toc:()=>p});var r=a(83117),n=a(80102),o=(a(67294),a(3905)),i=["components"],l={},s=void 0,d={unversionedId:"XND module/FlowControl XND Module",id:"version-1.6/XND module/FlowControl XND Module",title:"FlowControl XND Module",description:"Introduction to XND Module",source:"@site/versioned_docs/version-1.6/04-XND module/02-FlowControl XND Module.md",sourceDirName:"04-XND module",slug:"/XND module/FlowControl XND Module",permalink:"/1.6/XND module/FlowControl XND Module",draft:!1,tags:[],version:"1.6",lastUpdatedAt:1639746315,formattedLastUpdatedAt:"17 Dec 2021",sidebarPosition:2,frontMatter:{},sidebar:"version-1.6/docs",previous:{title:"Performance",permalink:"/1.6/XND module/Performance"},next:{title:"DDoS Mitigation",permalink:"/1.6/XND module/DDoS Mitigation"}},m={},p=[{value:"Introduction to XND Module",id:"introduction-to-xnd-module",level:3},{value:"XDN module operation diagram",id:"xdn-module-operation-diagram",level:3},{value:"Data filtering",id:"data-filtering",level:3},{value:"Data Grouping",id:"data-grouping",level:3},{value:"Static thresholds",id:"static-thresholds",level:3},{value:"Dynamic thresholds",id:"dynamic-thresholds",level:3},{value:"XND module response to the DDoS attacks",id:"xnd-module-response-to-the-ddos-attacks",level:3}],u={toc:p};function c(e){var t=e.components,l=(0,n.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"introduction-to-xnd-module"},"Introduction to XND Module"),(0,o.kt)("p",null,"\u200b\tThe FC XND module uses aggregated NetFlow, sFlow, NSEL data. Based on this data and parameters entered by the user, the algorithm calculates a set of data defining the target together with the attacked service and can then take action to limit the effects of the attack. DDoS attacks are detected by the XND module algorithm based on the parameters: static thresholds and dynamic thresholds."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Static thresholds")," are used to optimize and reduce the number of False Positives by filtering network traffic that do not meet quantitative parameters such as: bytes limit, packet limit or unique source IP addresses. All static threshold parameters have to be exceeded in order for the algorithm to start the next step, i.e. calculation of dynamic threshold parameters."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Dynamic thresholds (behavioral)")," are used to compare current network traffic characteristics with the previous sample (baseline). By default, a baseline is created for 15 minutes before the attack. The dynamic threshold parameters are configured in the XND module as a so-called multiplier, which means that multiple of a given indicator cannot be exceeded. The indicator parameter specifies the number of dynamic thresholds that must be exceeded for an attack to be confirmed from the behavioral analysis point of view. "),(0,o.kt)("p",null,"\u200b\tThe DDoS mechanism also uses two types of whitelists: ",(0,o.kt)("strong",{parentName:"p"},"ASN whitelist")," and ",(0,o.kt)("strong",{parentName:"p"},"service whitelist")," ",(0,o.kt)("strong",{parentName:"p"},"\u2013 monitoring mode"),". The first one is used to define source ASNs to be ignored from the XND module algorithm calculation. The service whitelist, on the other hand, is used to define the services for which only DDoS alerts will be generated, and blocking will not be triggered for them using the BGP FlowSpec protocol or RTBH (Remote Triggered Black Hole Routing)."),(0,o.kt)("p",null,"\u200b\tAll parameters of the DDoS detection algorithm are configured in relation to the ",(0,o.kt)("strong",{parentName:"p"},"function group (Settings/Mapping/Groups/Function),"),"  ",(0,o.kt)("em",{parentName:"p"},"Fig. 2.1.1.")," Here the resources subject to the procedure contained in the XND module are configured, thus it is possible to fine-tune the XND module mechanism."),(0,o.kt)("img",{src:a(32169).Z,alt:"image-20201112123813503",style:{zoom:"67%"}}),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Fig. 2.1.1 XND groups configuration parameters")),(0,o.kt)("h3",{id:"xdn-module-operation-diagram"},"XDN module operation diagram"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"Fig. 2.2.1")," shows the operating principle and the individual analysis steps contained in the FlowControl XND module as a diagram."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image-20201112124555675",src:a(50252).Z,width:"1679",height:"800"})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Fig. 2.2.1 Concept of the DDoS algorithm implemented in XND module"),"  "),(0,o.kt)("h3",{id:"data-filtering"},"Data filtering"),(0,o.kt)("p",null,"\u200b\tOne of the first operations performed by the XND module on input data strings is pre-filtering. Its task should be filter out redundant motion for the analysis algorithm before the grouping process. "),(0,o.kt)("p",null,"Pre-filtration includes:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Target host filtering - filters the target IP addresses of monitored resources. These addresses are configured using function groups defined in the Engine Parameters."),(0,o.kt)("li",{parentName:"ol"},"TCP client traffic filtering \u2013 used to filtering the incoming traffic to the monitored resource, which is a response to queries to external resources. This step is implemented in the FlowControl system engine."),(0,o.kt)("li",{parentName:"ol"},"Source ASN filtering \u2013 defines ASNs that are excluded from analysis by the XND Module algorithm.")),(0,o.kt)("h3",{id:"data-grouping"},"Data Grouping"),(0,o.kt)("p",null,"\u200b\tAnother activity carried out by the XND module is the network traffic aggregation, i.e. data grouping. This operation is necessary to calculate a set of parameters that determine the target with the attacked service. In this process the following indicators are calculated:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Unique IP addresses"),(0,o.kt)("li",{parentName:"ol"},"Unique ASNs"),(0,o.kt)("li",{parentName:"ol"},"Unique internal IP addresses"),(0,o.kt)("li",{parentName:"ol"},"Unique public IP addresses"),(0,o.kt)("li",{parentName:"ol"},"Flow counter "),(0,o.kt)("li",{parentName:"ol"},"Number of packets"),(0,o.kt)("li",{parentName:"ol"},"Number of bytes"),(0,o.kt)("li",{parentName:"ol"},"PPF (Packets per Flow )"),(0,o.kt)("li",{parentName:"ol"},"BPP (Bytes per Packets)"),(0,o.kt)("li",{parentName:"ol"},"BPF (Bytes per Flow).   ")),(0,o.kt)("p",null,"For a DDoS attack, each set of parameters defining the target together with the service under attack, is a combination of such attributes as: target host, protocol, application and traffic direction. The set parameters defining the target together with the service is ",(0,o.kt)("strong",{parentName:"p"},"DDoS destination attack identifier (DDA Id).")),(0,o.kt)("h3",{id:"static-thresholds"},"Static thresholds"),(0,o.kt)("p",null,"\u200b\tThe static threshold parameters are represented by the following limits: flow limit, byte limit, and unique IPs limit \u2013 ",(0,o.kt)("em",{parentName:"p"},"Table")," ",(0,o.kt)("em",{parentName:"p"},"2.5.1.")," They allow data selection for the analyzed sample in order to determine which data will be taken into account in further steps in the algorithm. At this stage pre-filtered network traffic from the last minute is filtered using the above mentioned limits. In case all static thresholds for a specific DDA Id are exceeded, the XND module algorithm goes to the dynamic parameters analysis procedure. In other cases the algorithm performs filtering with static thresholds for the traffic sample from the next minute."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Static Threshold")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Description")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Flows Limit")),(0,o.kt)("td",{parentName:"tr",align:null},"Minimum number of network flows related to DDA Id.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Bytes Limit")),(0,o.kt)("td",{parentName:"tr",align:null},"Minimum number of bytes related to DDA I expressed in ","[MB]",".")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Unique IPs Limit")),(0,o.kt)("td",{parentName:"tr",align:null},"Minimum number of unique source IP addresses related to DDA Id.")))),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Table 2.5.1 Static threshold parameters.")),(0,o.kt)("p",null,"\u200b\tValues of the static threshold parameters are configured in the Engine Parameters tab as shown in ",(0,o.kt)("em",{parentName:"p"},"Fig. 2.5.2.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image-20201112130154333",src:a(53438).Z,width:"1300",height:"686"})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Fig. 2.5.2 Static threshold parameters configuration"),"  "),(0,o.kt)("h3",{id:"dynamic-thresholds"},"Dynamic thresholds"),(0,o.kt)("p",null,"\u200b\tTen dynamic thresholds and indicator limits are implemented in the FC XND module. They are described in ",(0,o.kt)("em",{parentName:"p"},"Table 2.6.1"),".    "),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Dynamic Thresholds"),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Description")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Unique ASNs")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of unique ASNs related to DDA ID.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Unique IPs")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of all unique source IP addresses (external and internal) related to DDA ID.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Unique Internal IPs")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of all unique source internal IP addresses related to DDA Id. Internal (private) addresses are configured in the Settings/Mapping/Groups/Internal tab.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Unique Public IPs")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of all unique source external IP addresses related to DDA Id.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Flows")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of flows related to DDA ID.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Packets")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of packets related to DDA ID.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Bytes")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of bytes related to DDA ID.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"PPF (Packets per Flow)")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of packets per network flows calculated as sum of packets divided by sum of network flows in context of DDA ID.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"BPP (Bytes per Packet)")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of bytes per packet calculated as sum of bytes divided by sum of packets in context of DDA Id.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"BPF (Bytes per Flow)")),(0,o.kt)("td",{parentName:"tr",align:null},"Number of bytes per flows calculated as sum of bytes divided by sum of the flows in context of DDA Id.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Indicator Limit")),(0,o.kt)("td",{parentName:"tr",align:null},"Threshold \u2013 specifies the number of threshold limit parameters that must be exceeded for the algorithm to consider the analysis to be positive.")))),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Table 2.6.1 Dynamic threshold parameters")," "),(0,o.kt)("p",null,"The value of the ",(0,o.kt)("strong",{parentName:"p"},"Indicator Limit")," controls parameters determining how many dynamic parameters must be exceeded for the algorithm to consider the analysis to be positive."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Example:")),"  ",(0,o.kt)("em",{parentName:"p"},"\u201cIndicators limit = 2\u201d - this means that only two out of ten parameters of the dynamic threshold limits listed in Table 2.6.1 are exceeded for the algorithm to give a positive result.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),": for the parameter \u201cIndicators limit =0\u201d the algorithm for dynamic analysis always gives a positive result!")),(0,o.kt)("p",null,"\u200b\tValues of the dynamic threshold parameters from are configured in the Engine Parameters tab as shown in ",(0,o.kt)("em",{parentName:"p"},"Fig. 2.6.1.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"image-20201112130232708",src:a(10800).Z,width:"1231",height:"644"})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Fig. 2.6.1 Dynamic threshold parameters configuration")," "),(0,o.kt)("p",null,"\u200b\tDynamic threshold parameters are calculated using analysis behavioral mechanism for defined function groups. This mechanism uses data from time intervals preceding the analyzed sample - so-called reference data. This is base data which is used to calculate average values for a set of metrics necessary to detect DDoS attacks. A reference data is data averaged from the last fifteen minutes preceding the analyzed sample. This is used in the comparison process with the analyzed data to calculate dynamic threshold parameters. ",(0,o.kt)("em",{parentName:"p"},"Fig. 2.6.2")," shows time intervals used to calculate dynamic threshold parameters. "),(0,o.kt)("img",{src:a(72591).Z,alt:"image-20201112130304664",style:{zoom:"80%"}}),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Fig. 2.6.2 Time intervals for determining reference and analysed data")),(0,o.kt)("p",null,"The dynamic thresholds during an ongoing attack are calculated by the algorithm in a different way than at the beginning of the attack. In such a case the value of each dynamic threshold parameter exceeded must be less than half of the threshold value set by the user for it to be treated as an unexceeded parameter."),(0,o.kt)("hr",null),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"NOTE:")),(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"For the DDoS algorithm to work correctly, you must set the values for all Engine Parameters, both static ",(0,o.kt)("em",{parentName:"strong"},"(Fig. 2.5.2)")," and dynamic ",(0,o.kt)("em",{parentName:"strong"},"(Fig. 2.6.1).")))),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"xnd-module-response-to-the-ddos-attacks"},"XND module response to the DDoS attacks"),(0,o.kt)("p",null,"\u200b\tIn the next step of the algorithm implementation, depending on the configuration of the XND module, one of two actions can take place according to ",(0,o.kt)("em",{parentName:"p"},"Fig. 2.2.1"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Generating an alarm and block the offending traffic on routers using FlowSpec or RTBH functionality."),(0,o.kt)("li",{parentName:"ol"},"Generating an alarm only if the service has been entered on the service whitelist.")))}c.isMDXComponent=!0},32169:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/image-20201112123813503-e55fbcddb44e29781bd6aa15ae19d754.png"},72591:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/image-20201112130304664-d7f57c1ae50e6561a06952b73e0c6aa1.png"},50252:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/image-20201112124555675-f970ac039bf517104c25d1c15ff91de5.png"},53438:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/image-20201112130154333-64a81391486f20086858081e37c2dcac.png"},10800:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/image-20201112130232708-b2238f541b2e1e97527f22abaeb7658a.png"}}]);